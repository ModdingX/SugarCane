import io.github.noeppi_noeppi.tools.modgradle.api.JavaEnvironment
import io.github.noeppi_noeppi.tools.modgradle.api.Versioning
import io.github.noeppi_noeppi.tools.modgradle.util.task.ExtractFromZipTask
import io.github.noeppi_noeppi.tools.modgradle.util.task.ExtractInheritanceTask
import io.github.noeppi_noeppi.tools.modgradle.util.task.FileAsArtifactTask
import io.github.noeppi_noeppi.tools.modgradle.util.task.SanitizeParchmentTask
import io.github.noeppi_noeppi.tools.modgradle.util.task.PackAsZipTask
import net.minecraftforge.gradle.common.util.MavenArtifactDownloader
import org.apache.commons.io.file.PathUtils
import org.apache.maven.artifact.repository.metadata.Metadata
import org.apache.maven.artifact.repository.metadata.io.xpp3.MetadataXpp3Reader
import org.apache.maven.artifact.versioning.DefaultArtifactVersion
import org.w3c.dom.Element
import org.w3c.dom.Node

import javax.xml.parsers.DocumentBuilder
import javax.xml.parsers.DocumentBuilderFactory
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.nio.file.StandardCopyOption
import java.text.ParseException
import java.text.SimpleDateFormat
import java.time.LocalDate
import java.time.ZoneId
import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream

buildscript {
    repositories {
        maven { url = 'https://maven.minecraftforge.net/' }
        maven { url = 'https://maven.parchmentmc.org/' }
        maven { url = 'https://noeppi-noeppi.github.io/MinecraftUtilities/maven' }
        mavenCentral()
    }

    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:5.1.21'
        classpath 'io.github.noeppi_noeppi.tools:ModGradle:1.0.28'
        classpath 'org.apache.maven:maven-artifact:3.8.1'
        classpath 'org.apache.maven:maven-repository-metadata:3.8.1'
        classpath 'com.google.code.findbugs:jsr305:3.0.1'
        classpath 'commons-io:commons-io:2.11.0'
    }
}

group = 'io.github.noeppi_noeppi.sugarcane'
final String localMaven = '/var/www/maven'

InputStream forgeMetaStream = new URL("https://maven.minecraftforge.net/net/minecraftforge/forge/maven-metadata.xml").openStream()
Metadata forgeMetadata = new MetadataXpp3Reader().read(forgeMetaStream)
forgeMetaStream.close()
final String forgeVersion = forgeMetadata.versioning.versions.stream()
        .filter { it.startsWith("${project.mcv}-") }
        .sorted(Comparator.comparing(DefaultArtifactVersion::new).reversed())
        .findFirst().orElseThrow(() -> new IllegalStateException("No matching forge version found."))

InputStream parchmentMetaStram = new URL("https://maven.parchmentmc.org/org/parchmentmc/data/parchment-${project.mcv}/maven-metadata.xml").openStream()
Metadata parchmentMetadata = new MetadataXpp3Reader().read(parchmentMetaStram)
parchmentMetaStram.close()
final String parchmentVersion = parchmentMetadata.versioning.versions.stream()
        .filter { !it.contains("SNAPSHOT") }
        .sorted(Comparator.comparing(DefaultArtifactVersion::new).reversed())
        .findFirst().orElseThrow(() -> new IllegalStateException("No matching parchment version found."))

DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder()
InputStream parchmentPomInput = new URL("https://maven.parchmentmc.org/org/parchmentmc/data/parchment-${project.mcv}/${parchmentVersion}/parchment-${project.mcv}-${parchmentVersion}.pom").openStream()
final parchmentXml = builder.parse(parchmentPomInput)
parchmentPomInput.close()

String targetVersion = parchmentVersion
boolean shouldSkip = Files.exists(Paths.get(localMaven).resolve(project.group.toString().replace('.', '/')).resolve("sugarcane-${project.mcv}").resolve(parchmentVersion).resolve("sugarcane-${project.mcv}-${parchmentVersion}.pom"))

if (shouldSkip) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy.MM.dd")
    try {
        LocalDate zdt = LocalDate.ofInstant(dateFormat.parse(parchmentVersion).toInstant(), ZoneId.systemDefault())
        LocalDate now = LocalDate.now()
        if (zdt.until(now).getDays() > 14) {
            // No release for a long time. If forge has been updated since then, generate a new version
            SimpleDateFormat mavenDateFormat = new SimpleDateFormat("yyyyMMddHHmmss")
            LocalDate lastForgeUpdate = LocalDate.ofInstant(mavenDateFormat.parse(forgeMetadata.versioning.lastUpdated).toInstant(), ZoneId.systemDefault())
            if (zdt.until(lastForgeUpdate).getDays() > 1) {
                targetVersion = dateFormat.format(new Date())
                shouldSkip = false
            }
        }
    } catch (ParseException e) {
        println("Invalid version: " + parchmentVersion + ": " + e.getMessage())
    }
}

println("SugarCane for ${forgeVersion} parchment ${parchmentVersion}")
println("  Version ${targetVersion}")

if (shouldSkip) {
    println("Already generated. Skipping")
    
    // Generate dummy tasks so it does not fail
    task clean { }
    task publish { }
} else {
    apply plugin: 'java'
    apply plugin: 'net.minecraftforge.gradle'
    apply plugin: 'maven-publish'

    java.toolchain.languageVersion = JavaLanguageVersion.of(Versioning.getJavaVersion(project.mcv))
    
    minecraft {
        mappings channel: 'official', version: project.mcv
    }

    repositories {
        maven { url = 'https://maven.parchmentmc.org' }
        maven { url = 'https://noeppi-noeppi.github.io/MinecraftUtilities/maven' }
    }

    dependencies {
        minecraft "net.minecraftforge:forge:${forgeVersion}"
    }

    task extractMinecraftClasses {
        dependsOn build
        outputs.upToDateWhen { false }
        doLast {
            File file = MavenArtifactDownloader.generate(project, "net.minecraftforge:forge:${forgeVersion}_mapped_official_${project.mcv}", false)
            if (file == null) throw new IllegalStateException("Forge classes not found.")
            Files.createDirectories(project.file('build/mcdata').toPath())
            Files.copy(file.toPath(), project.file('build/mcdata/forge.jar').toPath(), StandardCopyOption.REPLACE_EXISTING)
            extractZip(file.toPath(), project.file('build/mcdata/classes').toPath())
        }
    }

    task extractMinecraftSources {
        dependsOn build
        outputs.upToDateWhen { false }
        doLast {
            File file = MavenArtifactDownloader.generate(project, "net.minecraftforge:forge:${forgeVersion}_mapped_official_${project.mcv}:sources", false)
            if (file == null) throw new IllegalStateException("Forge sources not found.")
            Files.createDirectories(project.file('build/mcdata').toPath())
            extractZip(file.toPath(), project.file('build/mcdata/sources').toPath())
        }
    }

    task downloadParchment {
        outputs.upToDateWhen { false }
        doLast {
            File file = MavenArtifactDownloader.download(project, "org.parchmentmc.data:parchment-${project.mcv}:${parchmentVersion}@zip", false)
            if (file == null) throw new IllegalStateException("Parchment export not found.")
            Files.createDirectories(project.file('build/mcdata').toPath())
            Files.copy(file.toPath(), project.file('build/mcdata/parchment.zip').toPath(), StandardCopyOption.REPLACE_EXISTING)
        }
    }

    task extractParchment(type: ExtractFromZipTask) {
        dependsOn downloadParchment
        input = project.file('build/mcdata/parchment.zip')
        output = project.file('build/mcdata/parchment.json')
        zipPath = 'parchment.json'
    }

    task extractInheritance(type: ExtractInheritanceTask) {
        dependsOn extractMinecraftClasses
        classes = project.file('build/mcdata/classes')
        output = project.file('build/mcdata/inheritance.txt')
        libraryPath = JavaEnvironment.getLibraryPath(project, compileJava)
    }

    task sanitizeData(type: SanitizeParchmentTask) {
        outputs.upToDateWhen { false }
        dependsOn extractInheritance
        dependsOn extractMinecraftSources
        dependsOn extractMinecraftClasses
        dependsOn extractParchment
        inheritance = project.file('build/mcdata/inheritance.txt')
        input = project.file('build/mcdata/parchment.json')
        output = project.file('build/mcdata/sugarcane.json')
        libraryPath = project.files(project.file('build/mcdata/forge.jar'), JavaEnvironment.getLibraryPath(project, compileJava))
        sources = project.file('build/mcdata/sources')
        ignore 'mcp'
        ignore 'net.minecraftforge'
    }

    task buildSugarCane(type: PackAsZipTask) {
        dependsOn sanitizeData
        input = project.file('build/mcdata/sugarcane.json')
        output = project.file('build/mcdata/sugarcane.zip')
        zipPath = 'sugarcane.json'
    }

    task artifactSugarCane(type: FileAsArtifactTask) {
        dependsOn buildSugarCane
        file = project.file('build/mcdata/sugarcane.zip')
        archiveBaseName = "sugarcane-${project.mcv}"
        archiveVersion = targetVersion
        archiveExtension = 'zip'
    }

    publishing {
        publications {
            mavenJava(MavenPublication) {
                groupId = project.group
                artifactId = "sugarcane-${project.mcv}"
                version = targetVersion
                artifact artifactSugarCane
                pom {
                    // Copy license and properties from parchment pom and add forge version
                    withXml {
                        Element xml = it.asElement()
                        def propertyNode = xml.ownerDocument.createElement('properties')
                        def parchmentVersionProperty = xml.ownerDocument.createElement('parchment_version')
                        parchmentVersionProperty.setTextContent(parchmentVersion)
                        propertyNode.appendChild(parchmentVersionProperty)
                        for (int i = 0; i < parchmentXml.firstChild.childNodes.length; i++) {
                            def node = parchmentXml.firstChild.childNodes.item(i)
                            if (node.nodeType == Node.ELEMENT_NODE && node.nodeName == 'licenses') {
                                xml.appendChild(xml.ownerDocument.importNode(node, true))
                            }
                            if (node.nodeType == Node.ELEMENT_NODE && node.nodeName == 'properties') {
                                for (int j = 0; j < node.childNodes.length; j++) {
                                    def property = node.childNodes.item(j)
                                    if (property.nodeType == Node.ELEMENT_NODE && property.nodeName == 'minecraft_version') {
                                        propertyNode.appendChild(xml.ownerDocument.importNode(property, true))
                                    }
                                }
                            }
                        }
                        def forgeProperty = xml.ownerDocument.createElement('forge_version')
                        forgeProperty.setTextContent(forgeVersion)
                        propertyNode.appendChild(forgeProperty)
                        xml.appendChild(propertyNode)
                    }
                }
            }
        }
        repositories {
            maven {
                url localMaven
            }
        }
    }
}

static void extractZip(Path zipFile, Path targetPath) {
    if (Files.exists(targetPath)) {
        PathUtils.deleteDirectory(targetPath)
    }
    Files.createDirectories(targetPath)
    ZipInputStream zin = new ZipInputStream(Files.newInputStream(zipFile))
    for (ZipEntry zf = zin.getNextEntry(); zf != null; zf = zin.getNextEntry()) {
        String name = zf.getName()
        while (name.startsWith("/")) name = name.substring(1)
        Path target = targetPath.resolve(name)
        if (zf.isDirectory()) {
            Files.createDirectories(target)
        } else {
            Files.createDirectories(target.getParent())
            Files.copy(zin, target)
        }
    }
    zin.close()
}
