import org.moddingx.modgradle.api.JavaEnvironment
import org.moddingx.modgradle.api.Versioning
import org.moddingx.modgradle.api.task.ClasspathExec
import org.moddingx.modgradle.api.task.ExtractFromZipTask
import org.moddingx.modgradle.api.task.FileAsArtifactTask
import org.moddingx.modgradle.api.task.PackAsZipTask
import net.minecraftforge.gradle.common.util.MavenArtifactDownloader
import org.apache.commons.io.file.PathUtils
import org.apache.maven.artifact.repository.metadata.Metadata
import org.apache.maven.artifact.repository.metadata.io.xpp3.MetadataXpp3Reader
import org.apache.maven.artifact.versioning.DefaultArtifactVersion
import org.apache.maven.model.Model;
import org.apache.maven.model.io.xpp3.MavenXpp3Reader;
import org.w3c.dom.Element
import org.w3c.dom.Node

import javax.xml.parsers.DocumentBuilder
import javax.xml.parsers.DocumentBuilderFactory
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.nio.file.StandardCopyOption
import java.text.ParseException
import java.text.SimpleDateFormat
import java.time.LocalDate
import java.time.ZoneId
import java.time.temporal.ChronoUnit;
import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream

buildscript {
    repositories {
        maven { url = 'https://maven.moddingx.org' }
        maven { url = 'https://maven.minecraftforge.net' }
        maven { url = 'https://maven.parchmentmc.org' }
        mavenCentral()
    }

    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:5.1.41'
        classpath 'org.moddingx:ModGradle:3.0.0'
        classpath 'org.apache.maven:maven-artifact:3.8.5'
        classpath 'org.apache.maven:maven-model:3.8.5'
        classpath 'org.apache.maven:maven-repository-metadata:3.8.5'
        classpath 'com.google.code.findbugs:jsr305:3.0.1'
        classpath 'commons-io:commons-io:2.11.0'
        
        // See https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44228
        classpath('org.apache.logging.log4j:log4j-api') { version { strictly '[2.17.2,)' } }
        classpath('org.apache.logging.log4j:log4j-core') { version { strictly '[2.17.2,)' } }
    }
}

group = 'org.moddingx.sugarcane'
final String localMaven = '/var/www/moddingx/maven'
final SOURCE_TRANSFORM_VERSION = '2.0.1'

InputStream forgeMetaStream = new URL("https://maven.minecraftforge.net/net/minecraftforge/forge/maven-metadata.xml").openStream()
Metadata forgeMetadata = new MetadataXpp3Reader().read(forgeMetaStream)
forgeMetaStream.close()
final String forgeVersion = forgeMetadata.versioning.versions.stream()
        .filter { it.startsWith("${project.mcv}-") }
        .sorted(Comparator.comparing(DefaultArtifactVersion::new).reversed())
        .findFirst().orElseThrow(() -> new IllegalStateException("No matching forge version found."))

InputStream parchmentMetaStram = new URL("https://maven.parchmentmc.org/org/parchmentmc/data/parchment-${project.mcv}/maven-metadata.xml").openStream()
Metadata parchmentMetadata = new MetadataXpp3Reader().read(parchmentMetaStram)
parchmentMetaStram.close()
final String parchmentVersion = parchmentMetadata.versioning.versions.stream()
        .filter { !it.contains("SNAPSHOT") }
        .sorted(Comparator.comparing(DefaultArtifactVersion::new).reversed())
        .findFirst().orElseThrow(() -> new IllegalStateException("No matching parchment version found."))

String versionForCompare = null
try {
    InputStream sugarcaneMetaStream = new URL("https://maven.moddingx.org/org/moddingx/sugarcane/sugarcane-${project.mcv}/maven-metadata.xml").openStream()
    Metadata sugarcaneMetadata = new MetadataXpp3Reader().read(sugarcaneMetaStream)
    sugarcaneMetaStream.close()
    versionForCompare = sugarcaneMetadata.versioning.versions.stream()
            .filter { !it.contains("SNAPSHOT") }
            .sorted(Comparator.comparing(DefaultArtifactVersion::new).reversed())
            .findFirst().orElse(parchmentVersion)
} catch (FileNotFoundException e) {
    //
}

DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder()
InputStream parchmentPomInput = new URL("https://maven.parchmentmc.org/org/parchmentmc/data/parchment-${project.mcv}/${parchmentVersion}/parchment-${project.mcv}-${parchmentVersion}.pom").openStream()
final parchmentXml = builder.parse(parchmentPomInput)
parchmentPomInput.close()

String targetVersion = parchmentVersion
boolean shouldSkip = Files.exists(Paths.get(localMaven).resolve(project.group.toString().replace('.', '/')).resolve("sugarcane-${project.mcv}").resolve(parchmentVersion).resolve("sugarcane-${project.mcv}-${parchmentVersion}.pom"))

if (shouldSkip && versionForCompare != null) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy.MM.dd")
    try {
        LocalDate zdt = LocalDate.ofInstant(dateFormat.parse(versionForCompare).toInstant(), ZoneId.systemDefault())
        LocalDate now = LocalDate.now()
        if (zdt.until(now, ChronoUnit.DAYS) > 14) {
            // No release for a long time. If forge has been updated since then, generate a new version
            InputStream sugarCanePom = new URL("https://maven.melanx.de/io/github/noeppi_noeppi/sugarcane/sugarcane-${project.mcv}/${versionForCompare}/sugarcane-${project.mcv}-${versionForCompare}.pom").openStream()
            Model sugarCaneModel = new MavenXpp3Reader().read(sugarCanePom)
            String lastForgeVersion = sugarCaneModel.getProperties().getProperty("forge_version")
            if (lastForgeVersion != null && new DefaultArtifactVersion(lastForgeVersion).compareTo(new DefaultArtifactVersion(forgeVersion))) {
                targetVersion = dateFormat.format(new Date())
                shouldSkip = false
            }
        }
    } catch (ParseException e) {
        println("Invalid version: " + versionForCompare + ": " + e.getMessage())
    }
}

if (shouldSkip && versionForCompare != null && new DefaultArtifactVersion(parchmentVersion).compareTo(new DefaultArtifactVersion(versionForCompare)) < 0) {
    // Set targetVersion to versionForCompare to give a better skip message.
    targetVersion = versionForCompare
}

println("SugarCane for ${forgeVersion} parchment ${parchmentVersion}")
println("  Version ${targetVersion}")

if (shouldSkip) {
    println("Already generated. Skipping")

    // Generate dummy tasks so it does not fail
    task clean { }
    task publish { }
} else {
    apply plugin: 'java'
    apply plugin: 'net.minecraftforge.gradle'
    apply plugin: 'maven-publish'

    java.toolchain.languageVersion = JavaLanguageVersion.of(Versioning.getJavaVersion(project.mcv))

    minecraft {
        mappings channel: 'official', version: project.mcv
    }

    repositories {
        maven { url = 'https://maven.moddingx.org' }
        maven { url = 'https://maven.minecraftforge.net' }
        maven { url = 'https://maven.parchmentmc.org' }
    }

    dependencies {
        minecraft "net.minecraftforge:forge:${forgeVersion}"
    }

    task extractMinecraftClasses {
        dependsOn build
        outputs.upToDateWhen { false }
        doLast {
            File file = MavenArtifactDownloader.generate(project, "net.minecraftforge:forge:${forgeVersion}_mapped_official_${project.mcv}", false)
            if (file == null) throw new IllegalStateException("Forge classes not found.")
            Files.createDirectories(project.file('build/mcdata').toPath())
            Files.copy(file.toPath(), project.file('build/mcdata/forge.jar').toPath(), StandardCopyOption.REPLACE_EXISTING)
            extractZip(file.toPath(), project.file('build/mcdata/classes').toPath())
        }
    }

    task extractMinecraftSources {
        dependsOn build
        outputs.upToDateWhen { false }
        doLast {
            File file = MavenArtifactDownloader.generate(project, "net.minecraftforge:forge:${forgeVersion}_mapped_official_${project.mcv}:sources", false)
            if (file == null) throw new IllegalStateException("Forge sources not found.")
            Files.createDirectories(project.file('build/mcdata').toPath())
            extractZip(file.toPath(), project.file('build/mcdata/sources').toPath())
        }
    }

    task downloadParchment {
        outputs.upToDateWhen { false }
        doLast {
            File file = MavenArtifactDownloader.download(project, "org.parchmentmc.data:parchment-${project.mcv}:${parchmentVersion}@zip", false)
            if (file == null) throw new IllegalStateException("Parchment export not found.")
            Files.createDirectories(project.file('build/mcdata').toPath())
            Files.copy(file.toPath(), project.file('build/mcdata/parchment.zip').toPath(), StandardCopyOption.REPLACE_EXISTING)
        }
    }

    task extractParchment(type: ExtractFromZipTask) {
        dependsOn downloadParchment
        input = project.file('build/mcdata/parchment.zip')
        output = project.file('build/mcdata/parchment.json')
        zipPath = 'parchment.json'
    }

    task extractInheritance(type: ClasspathExec) {
        dependsOn extractMinecraftClasses
        tool = "org.moddingx:SourceTransform:${SOURCE_TRANSFORM_VERSION}"
        args = provider {[
                'inheritance',
                '-c', project.file('build/mcdata/classes').toPath().toAbsolutePath().normalize().toString(),
                '-p', project.files(JavaEnvironment.getLibraryPath(project, compileJava)).asPath,
                '-o', project.file('build/mcdata/inheritance.txt').toPath().toAbsolutePath().normalize().toString()
        ]}
    }

    task sanitizeData(type: ClasspathExec) {
        outputs.upToDateWhen { false }
        dependsOn extractInheritance
        dependsOn extractMinecraftSources
        dependsOn extractMinecraftClasses
        dependsOn extractParchment
        tool = "org.moddingx:SourceTransform:${SOURCE_TRANSFORM_VERSION}"
        args = provider {[
                'sanitize',
                '-i', project.file('build/mcdata/inheritance.txt').toPath().toAbsolutePath().normalize().toString(),
                '-m', project.file('build/mcdata/parchment.json').toPath().toAbsolutePath().normalize().toString(),
                '-o', project.file('build/mcdata/sugarcane.json').toPath().toAbsolutePath().normalize().toString(),
                '-p', project.files(project.file('build/mcdata/forge.jar'), JavaEnvironment.getLibraryPath(project, compileJava)).asPath,
                '-s', project.file('build/mcdata/sources').toPath().toAbsolutePath().normalize().toString(),
                '--srg',
                '-b', 'mcp',
                '-b', 'net.minecraftforge'
        ]}
    }

    task buildSugarCane(type: PackAsZipTask) {
        dependsOn sanitizeData
        input = project.file('build/mcdata/sugarcane.json')
        output = project.file('build/mcdata/sugarcane.zip')
        zipPath = 'sugarcane.json'
    }

    task artifactSugarCane(type: FileAsArtifactTask) {
        dependsOn buildSugarCane
        file = project.file('build/mcdata/sugarcane.zip')
        archiveBaseName = "sugarcane-${project.mcv}"
        archiveVersion = targetVersion
        archiveExtension = 'zip'
    }

    publishing {
        publications {
            mavenJava(MavenPublication) {
                groupId = project.group
                artifactId = "sugarcane-${project.mcv}"
                version = targetVersion
                artifact artifactSugarCane
                pom {
                    // Copy license and properties from parchment pom and add forge version
                    withXml {
                        Element xml = it.asElement()
                        def propertyNode = xml.ownerDocument.createElement('properties')
                        def parchmentVersionProperty = xml.ownerDocument.createElement('parchment_version')
                        parchmentVersionProperty.setTextContent(parchmentVersion)
                        propertyNode.appendChild(parchmentVersionProperty)
                        for (int i = 0; i < parchmentXml.firstChild.childNodes.length; i++) {
                            def node = parchmentXml.firstChild.childNodes.item(i)
                            if (node.nodeType == Node.ELEMENT_NODE && node.nodeName == 'licenses') {
                                xml.appendChild(xml.ownerDocument.importNode(node, true))
                            }
                            if (node.nodeType == Node.ELEMENT_NODE && node.nodeName == 'properties') {
                                for (int j = 0; j < node.childNodes.length; j++) {
                                    def property = node.childNodes.item(j)
                                    if (property.nodeType == Node.ELEMENT_NODE && property.nodeName == 'minecraft_version') {
                                        propertyNode.appendChild(xml.ownerDocument.importNode(property, true))
                                    }
                                }
                            }
                        }
                        def forgeProperty = xml.ownerDocument.createElement('forge_version')
                        forgeProperty.setTextContent(forgeVersion)
                        propertyNode.appendChild(forgeProperty)
                        xml.appendChild(propertyNode)
                    }
                }
            }
        }
        repositories {
            maven {
                url localMaven
            }
        }
    }
}

static void extractZip(Path zipFile, Path targetPath) {
    if (Files.exists(targetPath)) {
        PathUtils.deleteDirectory(targetPath)
    }
    Files.createDirectories(targetPath)
    ZipInputStream zin = new ZipInputStream(Files.newInputStream(zipFile))
    for (ZipEntry zf = zin.getNextEntry(); zf != null; zf = zin.getNextEntry()) {
        String name = zf.getName()
        while (name.startsWith("/")) name = name.substring(1)
        Path target = targetPath.resolve(name)
        if (zf.isDirectory()) {
            Files.createDirectories(target)
        } else {
            Files.createDirectories(target.getParent())
            Files.copy(zin, target)
        }
    }
    zin.close()
}
